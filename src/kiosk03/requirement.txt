### Lv 3. 객체 지향 설계를 적용해 순서 제어를 클래스로 관리하기

- [ ]  **요구사항이 가지는 의도**
    - [ ]  객체 지향 개념을 학습하고, 데이터를 구조적으로 관리하며 프로그램을 설계하는 방법을 익힙니다.
    - [ ]  `main` 함수에서 관리하던 전체 순서 제어를 `Kiosk` 클래스를 통해 관리합니다.
- [ ]  **`Kiosk` 클래스 생성하기**
    - [ ]  **설명**: 키오스크 프로그램의 메뉴를 관리하고 사용자 입력을 처리하는 클래스입니다.
    - [ ]  `MenuItem`을 관리하는 리스트가 필드로 존재합니다.
    - [ ]  `main` 함수에서 관리하던 입력과 반복문 로직은 이제 `start` 함수를 만들어 관리합니다.
    - [ ]  `List<MenuItem> menuItems` 는 `Kiosk` 클래스 생성자를 통해 값을 할당합니다.
        - [ ]  `Kiosk` 객체를 생성하고 사용하는 `main` 함수에서 객체를 생성할 때 값을 넘겨줍니다.
- [ ]  요구사항에 부합하는지 검토
    - [ ]  키오스크 프로그램을 시작하는 메서드가 구현되어야 합니다.
        - [ ]  콘솔에 햄버거 메뉴를 출력합니다.
        - [ ]  사용자의 입력을 받아 메뉴를 선택하거나 프로그램을 종료합니다.
        - [ ]  유효하지 않은 입력에 대해 오류 메시지를 출력합니다.
        - [ ]  `0`을 입력하면 프로그램이 ‘뒤로가기’되거나 ‘종료’됩니다.


이제 요구사항에서 Kiosk 클래스 작성을 명시했으니 메인함수 실행하는 클래스는 App으로 설정

Kiosk 클래스 따로 만들기

MenuItem을 관리하는 리스트가 필드로 존재한다
-> 여태 했던 기능들을 그냥 Kiosk 클래스 내부에서 해결하겠다 라고 생각하면 될듯함
start 함수를 만들어 관리한다.
start 메서드에서 함수 입력과 반복문 로직을 실행한다고 이해해야 할듯함

List<MenuItem> menuItems` 는 `Kiosk` 클래스 생성자를 통해 값을 할당합니다.
-> 이제 MenuItem 클래스는 kiosk의 하위 클래스라고 생각하는 게 좋을듯 싶음
-> toString 메서드를 가지고 있는 느낌.


이제 본격적으로 Kiosk 클래스를 만들 때 고려해야 할 것 중 첫번째로 필드를 생각해야 함

일단 `MenuItem`을 관리하는 리스트가 필드 첫 번째.
이것부터 생성

그리고
키오스크를 실행할 메서드가 구현되어야 한다고 하는데
일단 키오스크 클래스에서 필드 하나를 정수값으로 받아온 뒤 값에 따라 선택하게 하는
키오스크 자체의 메뉴가 있어야 할 것 같음
1. 햄버거 메뉴 보기
2. 언어 선택하기 // 구현할생각없음 아직
3. 종료
이런 식으로 구현하면 될 듯함.
-> level4에 메뉴 클래스가 따로 존재하니 그냥 메인 함수에 간단하게 진행하는 게 좋아보임.
---------------------------------------------------------
⚠️ 잘못생각한 부분

두 관계를 상속관계라고 생각했음
Kiosk 클래스가 MenuItem의 부모 클래스라고 생각함
그래서 Kiosk에서도 MenuItem의 객체를 들고 있어야 하는지에 대해 의문을 품음.

-------------------------------------------------
▶️ 위 과정에서 상속에 대해 다시 알아보던 중 잘못 생각했다는 것을 알게 됨.

🔎 깨달은 점
여기서 상속관계 개념을 적용하려했는데 상속관계의 경우,
두 클래스가 서로가 일치해야 하는 부분이  있어야 하는데
이 경우에는 그러하지 않다.
따라서 키오스크 내부에서 메뉴 아이템을 관리하는 격이라고 생각해야 함.
그냥 포함하는 상위 클래스라고 생각하고 진행해야 한다.
여기서 포함관계(Composition)은 한 클래스가 다른 클래스를 필드로 가지는 관계를 뜻한다.

추가로 이렇게 포함관계로 클래스를 구성할 경우,
상속관계처럼 클래스이름에 extends 같은 코드를 입력할 필요 없고
List<MenuItem> menuItems = new ArrayList<>();
이 코드 하나만으로도 Kiosk 클래스에서 MenuItem의 객체를 가져다 사용할 수 있다.
-> 생각해보면 어차피 메뉴 추가하는 메서드를 Kiosk에서 만들것이기 때문에
MenuItem은 단순히 메뉴의 리스트를 저장하고 있는 클래스일 뿐임.
-> 메뉴 추가

🔥 종료 메뉴가 항상 음식메뉴의 하단에 위치하고, 0을 고정으로 받아야 함.

printMenu() <- 메뉴 출력하기
메서드 시작 시, 종료 메뉴가 있는 지에 대한 여부를 파악하고
종료 메뉴가 있다면 제거하는 코드를 작성
이후 for문을 통해 기존 메뉴를 출력한 뒤,
마지막에 종료 메뉴를 출력하는 로직을 작성
-> 이 과정에서 마지막에 종료 메뉴를 추가하는 로직으로 하려 했는데
-> 종료 메뉴가 없으면 없는대로 진행하고 마지막에 어차피 종료 메뉴를 출력하기 때문에
-> 굳이 메뉴에 종료 메뉴를 항상 추가할 이유가 없다
-> 메모리적으로도 손해일 것 같다고 판단해서 제외함
-> 이 로직대로라면 기존 메뉴 불러올때도 종료 메뉴가 있을 이유가 없다고 생각함
-> 기존 메뉴에서도 0.종료 메뉴 삭제.
-> 이렇게 하면 toString 구문에서 0일때만 진행했던 if문도 삭제가 가능하기에 삭제
-> 추가로 처음에 하려 했던 종료 메뉴가 있는지 확인하는 여부의 if문도 필요없어 보여서 삭제
-> 대신, 메뉴가 없는데 출력하려 할 시, 오류 메세지 출력하게끔 변경
-> 이후 반복문을 선택지 입력하는 곳에 씌움
-> 메뉴 추가 시, x를 입력해 탈출했을 때, 다시 선택지 입력하는 곳으로 안 오고
-> 공백이 출력
-> 버퍼문제일 것 같음
-> 맞음
-> level3 종료